<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ラッキーパネル補助ツール</title>

<link rel="icon" href="LuckyPanel_favicon.png" type="image/png">
<link rel="apple-touch-icon" href="LuckyPanel_favicon.png">
<style>
    body {
        font-family: "Helvetica Neue", Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: #f8f9fa;
        padding: 20px;
        color: #333;
        -webkit-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
        overscroll-behavior: none;
    }

    h1 {
        margin-bottom: 10px;
        font-size: 1.4rem;
        color: #444;
    }

    .controls {
        margin-bottom: 15px;
        display: flex;
        flex-direction: column;
        gap: 15px;
        align-items: center;
        background: white;
        padding: 15px 25px;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        width: 95%; /* 横幅を少し広げました */
        max-width: 600px;
    }

    .mode-group {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        justify-content: center;
    }

    .action-group {
        display: flex;
        gap: 15px;
    }

    .mode-btn {
        padding: 8px 12px;
        font-size: 0.9rem;
        border: 2px solid #ddd;
        border-radius: 20px;
        cursor: pointer;
        background-color: #fff;
        color: #555;
        transition: all 0.2s;
        font-weight: bold;
    }

    .mode-btn.active {
        background-color: #007bff;
        color: white;
        border-color: #007bff;
        box-shadow: 0 2px 5px rgba(0,123,255,0.3);
    }

    .action-btn {
        padding: 10px 30px;
        font-size: 1rem;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        color: white;
        transition: background-color 0.2s;
        min-width: 100px;
    }

    #resetBtn { background-color: #6c757d; }
    #nextBtn { background-color: #007bff; }

    .status-bar {
        margin-bottom: 10px;
        font-weight: bold;
        height: 1.5em;
        color: #555;
    }
    .next-char {
        color: #d35400;
        font-size: 1.2em;
        margin-left: 5px;
    }

    .grid-container {
        display: grid;
        gap: 5px; /* マスが増えるため隙間を少し狭く */
        background-color: #555;
        padding: 8px;
        border-radius: 8px;
        box-shadow: 0 6px 12px rgba(0,0,0,0.15);
        touch-action: none;
    }

    .cell {
        /* マスサイズを少し調整（激辛モードで画面からはみ出ないように） */
        width: 55px; 
        height: 55px;
        background-color: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 1.5rem;
        font-weight: bold;
        cursor: pointer;
        border-radius: 4px;
        box-shadow: inset 0 0 2px rgba(0,0,0,0.1);
        transition: transform 0.1s;
        color: #444;
        position: relative;
    }

    /* 画面幅が狭いスマホ用の調整 */
    @media (max-width: 400px) {
        .cell {
            width: 45px;
            height: 45px;
            font-size: 1.2rem;
        }
    }

    .cell.empty {
        background-color: #e9ecef;
        color: transparent;
    }
    
    /* カラーパレット */
    .bg-A { background-color: #ff97a2; }
    .bg-B { background-color: #85abf1; }
    .bg-C { background-color: #f7cf86; }
    .bg-D { background-color: #eaad48; }
    .bg-E { background-color: #c5af9c; }
    .bg-F { background-color: #c8e6c9; }
    .bg-G { background-color: #a3d07d; }
    .bg-H { background-color: #ffc0cb; }
    .bg-I { background-color: #b3e5fc; }
    /* 新規追加カラー */
    .bg-J { background-color: #d1c4e9; } /* 薄紫 */
    .bg-K { background-color: #b2dfdb; } /* 薄ティール */

    .bg-star { background-color: #fff176; color: #f57f17; border: 2px solid #fbc02d; }
    .bg-close { background-color: #e1bee7; color: #8e44ad; font-weight: 900; }

    .cell:not(.empty) { cursor: grab; border: 1px solid rgba(0,0,0,0.05); }
    
    .cell.dragging {
        opacity: 0.6;
        transform: scale(1.1);
        z-index: 999;
        box-shadow: 0 10px 20px rgba(0,0,0,0.2);
    }
    .cell.over {
        border: 2px dashed #007bff !important;
        opacity: 0.8;
        transform: scale(0.95);
    }

</style>
</head>
<body>

    <h1>ラッキーパネル補助ツール</h1>
    
    <div class="controls">
        <div class="mode-group">
            <button class="mode-btn" id="btnMode1" onclick="selectMode(1)">①甘口</button>
            <button class="mode-btn" id="btnMode2" onclick="selectMode(2)">②中辛</button>
            <button class="mode-btn" id="btnMode3" onclick="selectMode(3)">③辛口</button>
            <button class="mode-btn" id="btnMode4" onclick="selectMode(4)">④激辛</button>
        </div>
        <div class="action-group">
            <button class="action-btn" id="resetBtn" onclick="resetCurrentGame()">リセット</button>
            <button class="action-btn" id="nextBtn" onclick="nextMode()">次へ</button>
        </div>
    </div>

    <div class="status-bar" id="statusBar">
        次は:<span class="next-char" id="nextCharDisplay">-</span>
    </div>

    <div class="grid-container" id="grid"></div>

<script>
    // モード定義
    const modes = {
        1: { rows: 3, cols: 4, chars: ['A', 'B', 'C', 'D', 'E'] },
        2: { rows: 4, cols: 4, chars: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
        3: { rows: 4, cols: 5, chars: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'] },
        4: { rows: 4, cols: 6, chars: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K'] }
    };

    // カラーマップ
    const colorMap = {
        'A': 'bg-A', 'B': 'bg-B', 'C': 'bg-C', 'D': 'bg-D', 'E': 'bg-E',
        'F': 'bg-F', 'G': 'bg-G', 'H': 'bg-H', 'I': 'bg-I', 'J': 'bg-J', 'K': 'bg-K',
        '★': 'bg-star', '〆': 'bg-close'
    };

    let currentModeId = 1; 
    let supplyQueue = [];  
    let dragSrcEl = null;
    let touchStartX = 0;
    let touchStartY = 0;
    let isDraggingMode = false;

    const gridElement = document.getElementById('grid');
    const nextCharDisplay = document.getElementById('nextCharDisplay');
    const statusBar = document.getElementById('statusBar');

    // モード選択
    function selectMode(id) {
        currentModeId = id;
        document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`btnMode${currentModeId}`).classList.add('active');
        initGame();
    }

    // 次へボタン (ローテーション 1->2->3->4->1)
    function nextMode() {
        let nextId = currentModeId + 1;
        if (nextId > 4) nextId = 1;
        selectMode(nextId);
    }

    function resetCurrentGame() {
        initGame();
    }

    // ゲーム初期化
    function initGame() {
        const config = modes[currentModeId];
        supplyQueue = [];
        config.chars.forEach(char => { supplyQueue.push(char); supplyQueue.push(char); });
        supplyQueue.push('★');
        supplyQueue.push('〆');
        updateStatus();

        gridElement.style.gridTemplateColumns = `repeat(${config.cols}, auto)`;
        // グリッド幅はCSSでセルサイズ固定にしているが、スマホで4x6は狭いのでauto推奨
        // ただし見た目の統一感のため、ここではCSSのwidthを優先しつつ列数指定のみ行う
        
        // CSS変数で列数を渡してレスポンシブ対応も可能だが、
        // 簡易的にJSで列定義を書き換える
        // width: auto だと崩れるため、少し調整
        
        // スマホで激辛(幅6)を表示するため、Grid定義をシンプルに
        // 列の幅は .cell の幅に依存させる
        gridElement.style.gridTemplateColumns = `repeat(${config.cols}, min-content)`;
        
        gridElement.innerHTML = '';

        const totalCells = config.rows * config.cols;
        for (let i = 0; i < totalCells; i++) {
            createCell();
        }
    }

    function createCell() {
        const cell = document.createElement('div');
        cell.classList.add('cell', 'empty');
        addEvents(cell);
        gridElement.appendChild(cell);
    }

    function updateStatus() {
        if (supplyQueue.length > 0) {
            nextCharDisplay.textContent = supplyQueue[0];
            statusBar.style.visibility = 'visible';
        } else {
            nextCharDisplay.textContent = "完了";
            statusBar.style.visibility = 'hidden';
        }
    }

    function processInput(cell) {
        if (!cell.classList.contains('empty') || supplyQueue.length === 0) return;

        const item = supplyQueue.shift();
        setItemToCell(cell, item);

        if (item === '★' && supplyQueue.length === 1 && supplyQueue[0] === '〆') {
            const emptyCells = document.querySelectorAll('.cell.empty');
            if (emptyCells.length === 1) {
                const lastItem = supplyQueue.shift();
                setItemToCell(emptyCells[0], lastItem);
            }
        }
        updateStatus();
    }

    function setItemToCell(cell, item) {
        cell.textContent = item;
        cell.className = 'cell'; 
        if (colorMap[item]) cell.classList.add(colorMap[item]);
    }

    function swapCells(src, target) {
        const srcText = src.textContent;
        const srcClass = src.className;
        const targetText = target.textContent;
        const targetClass = target.className;

        const cleanClass = (cls) => cls.replace(' dragging', '').replace(' over', '');

        src.textContent = targetText;
        src.className = cleanClass(targetClass);

        target.textContent = srcText;
        target.className = cleanClass(srcClass);
    }

    function addEvents(cell) {
        cell.addEventListener('click', (e) => {
            if (e.detail === 0) return; 
            processInput(cell);
        });

        cell.setAttribute('draggable', true);
        cell.addEventListener('dragstart', handleDragStart);
        cell.addEventListener('dragover', handleDragOver);
        cell.addEventListener('drop', handleDrop);
        cell.addEventListener('dragend', handleDragEnd);

        cell.addEventListener('touchstart', handleTouchStart, {passive: false});
        cell.addEventListener('touchmove', handleTouchMove, {passive: false});
        cell.addEventListener('touchend', handleTouchEnd, {passive: false});
    }

    function handleDragStart(e) {
        dragSrcEl = this;
        e.dataTransfer.setData('text/html', this.innerHTML);
        this.classList.add('dragging');
    }
    function handleDragOver(e) {
        e.preventDefault();
        return false;
    }
    function handleDrop(e) {
        e.stopPropagation();
        if (dragSrcEl !== this) swapCells(dragSrcEl, this);
        return false;
    }
    function handleDragEnd() {
        this.classList.remove('dragging');
    }

    function handleTouchStart(e) {
        const touch = e.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
        isDraggingMode = false;
        dragSrcEl = this;
    }

    function handleTouchMove(e) {
        const touch = e.touches[0];
        const moveX = Math.abs(touch.clientX - touchStartX);
        const moveY = Math.abs(touch.clientY - touchStartY);

        if (moveX > 10 || moveY > 10) {
            isDraggingMode = true;
        }

        if (!isDraggingMode) return;

        e.preventDefault();
        this.classList.add('dragging');

        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        document.querySelectorAll('.cell').forEach(c => c.classList.remove('over'));
        
        if (target && target.closest('.cell')) {
            const targetCell = target.closest('.cell');
            if (targetCell !== dragSrcEl) {
                targetCell.classList.add('over');
            }
        }
    }

    function handleTouchEnd(e) {
        this.classList.remove('dragging');
        document.querySelectorAll('.cell').forEach(c => c.classList.remove('over'));

        if (!isDraggingMode) {
            e.preventDefault();
            processInput(this);
        } else {
            const touch = e.changedTouches[0];
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            
            if (target && target.closest('.cell')) {
                const targetCell = target.closest('.cell');
                if (dragSrcEl !== targetCell) {
                    swapCells(dragSrcEl, targetCell);
                }
            }
        }
    }

    selectMode(1);
</script>

</body>
</html>
