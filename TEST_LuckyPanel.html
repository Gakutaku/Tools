<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>ラッキーパネル補助ツール</title>
<link rel="icon" href="LuckyPanel_favicon.png" type="image/png">
<link rel="apple-touch-icon" href="LuckyPanel_favicon.png">

<style>
    /* =========================================
       ▼▼▼ 基本変数 (スマホ・横向き基準) ▼▼▼ 
       =========================================
    */
    :root {
        /* 高さ: (画面高さ - 上部要素計 約90px) ÷ 4行 */
        --ls-cell-h: calc((100vh - 90px) / 4);
        
        /* 幅: Save1の計算式(280px)だと隙間を確保した際に6列ではみ出すため、
           隙間分を含めて安全マージンを「360px」に調整しました。
           これでSave1の隙間を維持しつつ、全表示が可能になります。 */
        --ls-cell-w: calc((100vw - 360px) / 6);
        
        /* 小さい方を採用 */
        --ls-final-cell: min(var(--ls-cell-h), var(--ls-cell-w));
    }

    body {
        font-family: "Helvetica Neue", Arial, sans-serif;
        
        /* ▼▼▼ 【セーブ3】背景設定 ▼▼▼ */
        background-color: #e8dcb9; /* ベースの薄いベージュ */
        /* CSSグラデーションで簡易的な木目（縦縞）を表現 */
        background-image: 
            repeating-linear-gradient(90deg, 
                rgba(160, 120, 60, 0.05) 0px, 
                rgba(160, 120, 60, 0.05) 1px, 
                transparent 1px, 
                transparent 20px
            ),
            repeating-linear-gradient(90deg, 
                rgba(160, 120, 60, 0.03) 0px, 
                rgba(160, 120, 60, 0.03) 3px, 
                transparent 3px, 
                transparent 50px
            );
        /* ▲▲▲ 背景設定ここまで ▲▲▲ */

        color: #333;
        margin: 0;
        padding: 0;
        width: 100vw;
        height: 100vh;
        -webkit-user-select: none;
        user-select: none;
        -webkit-touch-callout: none;
        overscroll-behavior: none;
        -webkit-tap-highlight-color: transparent;
        display: flex;
        justify-content: center;
        overflow: hidden; 
    }

    h1 {
        margin: 0;
        padding: 5px 0;
        font-size: 1.2rem;
        color: #444;
        text-align: center;
        line-height: 1.2;
        /* 背景が木目になったので文字に少し白縁をつけて読みやすくする */
        text-shadow: 1px 1px 0 rgba(255,255,255,0.5);
    }

    .portrait-hint {
        font-size: 0.8rem;
        color: #c0392b; /* 背景がベージュなので見やすい赤に変更 */
        text-align: center;
        margin-top: 8px;
        font-weight: bold;
    }

    /* --- 共通: 縦向きレイアウト --- */
    .layout-container {
        width: 100%;
        max-width: 600px;
        padding: 10px;
        box-sizing: border-box;
        height: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .area-title   { order: 1; width: 100%; display: flex; justify-content: center; flex-shrink: 0; }
    .area-modes   { order: 2; width: 100%; display: flex; justify-content: center; margin-bottom: 8px; flex-shrink: 0; }
    .area-actions { order: 3; width: 100%; display: flex; justify-content: center; margin-bottom: 10px; flex-shrink: 0; }
    .area-status  { order: 4; width: 100%; display: flex; justify-content: center; margin-bottom: 5px; flex-shrink: 0; }
    .area-grid    { order: 5; width: 100%; display: flex; flex-direction: column; align-items: center; flex-grow: 1; overflow: hidden; }

    /* パーツ共通設定 */
    .mode-group { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
    .action-group { display: flex; gap: 15px; justify-content: center; width: 100%; max-width: 400px; flex-direction: row; }
    
    .mode-btn {
        padding: 8px 12px; font-size: 0.9rem; border: 2px solid #ddd; border-radius: 20px;
        cursor: pointer; background-color: #ac938a; color: #555; transition: all 0.2s; font-weight: bold; white-space: nowrap;
        /* ボタンにも少し影をつけて浮き上がらせる */
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .mode-btn.active { background-color: #57bd5c; color: white; border-color: #6d4c41; box-shadow: 0 2px 5px rgba(0,123,255,0.3); }

    .action-btn {
        padding: 10px 0; font-size: 1rem; border: none; border-radius: 4px;
        cursor: pointer; color: white; transition: background-color 0.2s; flex: 1; white-space: nowrap;
        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }
    #resetBtn { background-color: #adbb9f ; } /* #6c757d */
    #nextBtn { background-color: #009772 ; } /* #007bff */

    .status-bar { font-weight: bold; height: 1.5em; color: #555; display: flex; align-items: center; text-shadow: 1px 1px 0 rgba(255,255,255,0.5); }
    .next-char { color: #d35400; font-size: 1.2em; margin-left: 5px; }

    .grid-board {
        display: grid; gap: 4px; background-color: #555; padding: 6px;
        border-radius: 8px; box-shadow: 0 6px 12px rgba(0,0,0,0.15); touch-action: none; height: fit-content; 
    }

    .cell {
        width: 50px; height: 50px; background-color: #fff; display: flex; justify-content: center; align-items: center;
        font-size: 1.4rem; font-weight: bold; cursor: pointer; border-radius: 4px;
        box-shadow: inset 0 0 2px rgba(0,0,0,0.1); transition: transform 0.1s; color: #444;
        position: relative; box-sizing: border-box; border: 2px solid transparent;
    }
    @media (max-width: 360px) { .cell { width: 42px; height: 42px; font-size: 1.1rem; } }

    .cell.empty { background-color: #e9ecef; color: transparent; border: 2px solid #e9ecef; }
    .cell.filler { background-color: #555; border: 1px solid #666; cursor: default; box-shadow: none; pointer-events: none; }
    
    .bg-A { background-color: #ff97a2; } .bg-B { background-color: #85abf1; } .bg-C { background-color: #f7cf86; }
    .bg-D { background-color: #eaad48; } .bg-E { background-color: #c5af9c; } .bg-F { background-color: #c8e6c9; }
    .bg-G { background-color: #a3d07d; } .bg-H { background-color: #ffc0cb; } .bg-I { background-color: #b3e5fc; }
    .bg-J { background-color: #babec7; } .bg-K { background-color: #fbfff0; }
    .bg-star { background-color: #fff176; color: #f57f17; border: 2px solid #fbc02d; }
    .bg-close { background-color: #e1bee7; color: #8e44ad; font-weight: 900; border: 2px solid #ce93d8; }
    .cell:not(.empty):not(.bg-star):not(.bg-close):not(.filler) { border: 2px solid rgba(0,0,0,0.1); }
    .cell.dragging { opacity: 0.6; transform: scale(1.1); z-index: 999; box-shadow: 0 10px 20px rgba(0,0,0,0.2); }
    .cell.over { border: 2px dashed #007bff !important; opacity: 0.8; transform: scale(0.95); }


    /* =========================================
       ▼▼▼ 横向き（ランドスケープ）設定 ▼▼▼ 
       ========================================= */
    @media (orientation: landscape) {
        
        .layout-container {
            display: grid;
            /* 左(auto) - 中央(auto) - 右(固定85px) */
            grid-template-columns: auto auto 85px;
            grid-template-rows: auto auto 1fr;
            grid-template-areas:
                "title title title"
                "status status status"
                "modes grid actions";
            
            width: 100%;
            height: 100vh;
            max-width: none;
            /* Save1と同じ余白設定 */
            padding: 5px 10px; 
            column-gap: 20px; 
            row-gap: 2px;
        }

        .area-title, .area-status { order: initial; margin: 0; padding: 0; }
        .area-title   { grid-area: title; }
        .area-status  { grid-area: status; }
        h1 { font-size: 1rem; padding: 2px 0; }
        .status-bar { height: 1.2em; font-size: 0.9rem; margin-bottom: 2px; }

        /* 左エリア */
        .area-modes { 
            grid-area: modes; 
            height: 100%; 
            display: flex;
            align-items: flex-start; 
            justify-content: flex-end; 
            /* ★修正★ 枠の上辺と揃えるため余白を削除 (0 10px) */
            padding: 0 10px; 
        }
        
        /* 右エリア */
        .area-actions { 
            grid-area: actions; 
            height: 100%; 
            display: flex;
            align-items: flex-start; 
            justify-content: flex-start; 
            /* ★修正★ 枠の上下辺と揃えるため余白を削除 (0 10px) */
            padding: 0 10px; 
        }

        /* 中央エリア */
        .area-grid { 
            grid-area: grid; 
            height: 100%; 
            display: flex;
            justify-content: center; 
            align-items: flex-start; 
            overflow: hidden; 
            /* ここはpaddingなし */
        }

        /* 左ボタン */
        .mode-group {
            flex-direction: column;
            gap: 4px; /* 盤面gapと一致 */
            width: auto;
        }
        .mode-btn { 
            width: auto; 
            text-align: center; 
            padding: 0 12px; 
            font-size: 1rem;
            margin: 0;
            box-sizing: border-box;
            height: var(--ls-final-cell);
            display: flex; align-items: center; justify-content: center;
        }

        /* 右ボタン */
        .action-group {
            flex-direction: column-reverse; 
            justify-content: space-between; 
            gap: 15px; 
            width: 100%;
            height: 100%; 
            max-width: none;
        }
        .action-btn { 
            width: 100%; padding: 0; 
            display: flex; justify-content: center; align-items: center; flex-grow: 1; 
            font-size: 1.1rem;
        }
        
        /* 盤面 */
        .grid-board { 
            margin: 0 auto; 
            box-sizing: border-box;
            /* 枠消滅対策: max-content */
            width: max-content;
            height: auto;
            
            grid-template-columns: repeat(6, var(--ls-final-cell)) !important;
            grid-template-rows: repeat(4, var(--ls-final-cell)) !important;
        }
        
        .cell { 
            width: var(--ls-final-cell); 
            height: var(--ls-final-cell); 
            font-size: calc(var(--ls-final-cell) * 0.5); 
        }

        .portrait-hint { display: none; }
    }

    /* =========================================
       ▼▼▼ PC (大画面) 用の上書き設定 ▼▼▼ 
       ========================================= */
    @media screen and (min-width: 1024px) and (orientation: landscape) {
        :root {
            /* PC用: 左右200px+隙間を考慮して安全に引く */
            --ls-cell-w: calc((100vw - 650px) / 6);
        }

        .layout-container {
            /* 左右200px、中央可変 */
            grid-template-columns: 200px auto 200px;
        }
        
        .mode-btn { width: 100%; font-size: 1.5rem; }
        .action-btn { font-size: 1.5rem; }
    }

</style>
</head>
<body>

    <div class="layout-container">
        <div class="area-title">
            <h1>ラッキーパネル補助ツール</h1>
        </div>
        
        <div class="area-modes">
            <div class="mode-group">
                <button class="mode-btn" id="btnMode1" onclick="selectMode(1)">①甘口</button>
                <button class="mode-btn" id="btnMode2" onclick="selectMode(2)">②中辛</button>
                <button class="mode-btn" id="btnMode3" onclick="selectMode(3)">③辛口</button>
                <button class="mode-btn" id="btnMode4" onclick="selectMode(4)">④激辛</button>
            </div>
        </div>

        <div class="area-grid">
            <div class="grid-board" id="grid"></div>
            <div class="portrait-hint">※横向き推奨</div>
        </div>

        <div class="area-actions">
            <div class="action-group" id="actionGroup">
                <button class="action-btn" id="resetBtn" onclick="resetCurrentGame()">リセット</button>
                <button class="action-btn" id="nextBtn" onclick="nextMode()">次へ</button>
            </div>
        </div>

        <div class="area-status">
            <div class="status-bar" id="statusBar">
                次は:<span class="next-char" id="nextCharDisplay">-</span>
            </div>
        </div>
    </div>

<script>
    const modes = {
        1: { rows: 3, cols: 4, colOffset: 1, chars: ['A', 'B', 'C', 'D', 'E'] },
        2: { rows: 4, cols: 4, colOffset: 1, chars: ['A', 'B', 'C', 'D', 'E', 'F', 'G'] },
        3: { rows: 4, cols: 5, colOffset: 1, chars: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'] },
        4: { rows: 4, cols: 6, colOffset: 0, chars: ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K'] }
    };

    const colorMap = {
        'A': 'bg-A', 'B': 'bg-B', 'C': 'bg-C', 'D': 'bg-D', 'E': 'bg-E',
        'F': 'bg-F', 'G': 'bg-G', 'H': 'bg-H', 'I': 'bg-I', 'J': 'bg-J', 'K': 'bg-K',
        '★': 'bg-star', '〆': 'bg-close'
    };

    let currentModeId = 1; 
    let supplyQueue = [];  
    let dragSrcEl = null;
    let touchStartX = 0;
    let touchStartY = 0;
    let isDraggingMode = false;

    const gridElement = document.getElementById('grid');
    const nextCharDisplay = document.getElementById('nextCharDisplay');
    const statusBar = document.getElementById('statusBar');
    const actionGroup = document.getElementById('actionGroup');

    function selectMode(id) {
        currentModeId = id;
        document.querySelectorAll('.mode-btn').forEach(btn => btn.classList.remove('active'));
        document.getElementById(`btnMode${currentModeId}`).classList.add('active');
        initGame();
    }

    function nextMode() {
        let nextId = currentModeId + 1;
        if (nextId > 4) nextId = 1;
        selectMode(nextId);
    }

    function resetCurrentGame() {
        initGame();
    }

    function initGame() {
        const config = modes[currentModeId];
        supplyQueue = [];
        config.chars.forEach(char => { supplyQueue.push(char); supplyQueue.push(char); });
        supplyQueue.push('★');
        supplyQueue.push('〆');
        updateStatus();

        const isLandscape = window.matchMedia("(orientation: landscape)").matches;
        gridElement.innerHTML = '';

        if (isLandscape) {
            gridElement.style.gridTemplateColumns = `repeat(6, auto)`;
            gridElement.style.gridTemplateRows = `repeat(4, auto)`;
            const totalRows = 4;
            const totalCols = 6;

            for (let r = 0; r < totalRows; r++) {
                for (let c = 0; c < totalCols; c++) {
                    const isRowActive = r < config.rows;
                    const isColActive = c >= config.colOffset && c < (config.colOffset + config.cols);
                    const isActive = isRowActive && isColActive;
                    createCell(isActive);
                }
            }
            updateActionGroupHeight();
        } else {
            gridElement.style.gridTemplateColumns = `repeat(${config.cols}, min-content)`;
            gridElement.style.gridTemplateRows = `repeat(${config.rows}, min-content)`;
            const totalCells = config.rows * config.cols;
            for (let i = 0; i < totalCells; i++) {
                createCell(true);
            }
            actionGroup.style.height = '';
        }
    }
    
    window.addEventListener('resize', () => {
        initGame();
    });

    function updateActionGroupHeight() {
        const sampleCell = document.querySelector('.cell');
        if (sampleCell) {
            const cellSize = sampleCell.getBoundingClientRect().height;
            const gap = 4;
            const padding = 12; 
            const totalHeight = (cellSize * 4) + (gap * 3) + padding;
            actionGroup.style.height = `${totalHeight}px`;
        }
    }

    function createCell(isActive) {
        const cell = document.createElement('div');
        cell.classList.add('cell'); 
        
        if (!isActive) {
            cell.classList.add('filler');
        } else {
            cell.classList.add('empty');
            addEvents(cell);
        }
        gridElement.appendChild(cell);
    }

    function updateStatus() {
        if (supplyQueue.length > 0) {
            nextCharDisplay.textContent = supplyQueue[0];
            statusBar.style.visibility = 'visible';
        } else {
            nextCharDisplay.textContent = "完了";
            statusBar.style.visibility = 'hidden';
        }
    }

    function processInput(cell) {
        if (!cell.classList.contains('empty') || supplyQueue.length === 0) return;

        const item = supplyQueue.shift();
        setItemToCell(cell, item);

        if (item === '★' && supplyQueue.length === 1 && supplyQueue[0] === '〆') {
            const emptyCells = document.querySelectorAll('.cell.empty');
            if (emptyCells.length === 1) {
                const lastItem = supplyQueue.shift();
                setItemToCell(emptyCells[0], lastItem);
            }
        }
        updateStatus();
    }

    function setItemToCell(cell, item) {
        cell.textContent = item;
        cell.className = 'cell'; 
        if (colorMap[item]) cell.classList.add(colorMap[item]);
    }

    function swapCells(src, target) {
        const srcText = src.textContent;
        const srcClass = src.className;
        const targetText = target.textContent;
        const targetClass = target.className;

        const cleanClass = (cls) => cls.replace(' dragging', '').replace(' over', '');

        src.textContent = targetText;
        src.className = cleanClass(targetClass);

        target.textContent = srcText;
        target.className = cleanClass(srcClass);
    }

    function addEvents(cell) {
        cell.addEventListener('click', (e) => {
            if (e.detail === 0) return; 
            processInput(cell);
        });

        cell.setAttribute('draggable', true);
        cell.addEventListener('dragstart', handleDragStart);
        cell.addEventListener('dragover', handleDragOver);
        cell.addEventListener('drop', handleDrop);
        cell.addEventListener('dragend', handleDragEnd);

        cell.addEventListener('touchstart', handleTouchStart, {passive: false});
        cell.addEventListener('touchmove', handleTouchMove, {passive: false});
        cell.addEventListener('touchend', handleTouchEnd, {passive: false});
    }

    function handleDragStart(e) {
        dragSrcEl = this;
        e.dataTransfer.setData('text/html', this.innerHTML);
        this.classList.add('dragging');
    }
    function handleDragOver(e) {
        e.preventDefault();
        return false;
    }
    function handleDrop(e) {
        e.stopPropagation();
        if (dragSrcEl !== this) swapCells(dragSrcEl, this);
        return false;
    }
    function handleDragEnd() {
        this.classList.remove('dragging');
    }

    function handleTouchStart(e) {
        const touch = e.touches[0];
        touchStartX = touch.clientX;
        touchStartY = touch.clientY;
        isDraggingMode = false;
        dragSrcEl = this;
    }

    function handleTouchMove(e) {
        const touch = e.touches[0];
        const moveX = Math.abs(touch.clientX - touchStartX);
        const moveY = Math.abs(touch.clientY - touchStartY);

        if (moveX > 2 || moveY > 2) {
            isDraggingMode = true;
        }

        if (!isDraggingMode) return;

        e.preventDefault();
        this.classList.add('dragging');

        const target = document.elementFromPoint(touch.clientX, touch.clientY);
        document.querySelectorAll('.cell').forEach(c => c.classList.remove('over'));
        
        if (target && target.closest('.cell')) {
            const targetCell = target.closest('.cell');
            if (targetCell !== dragSrcEl && !targetCell.classList.contains('filler')) {
                targetCell.classList.add('over');
            }
        }
    }

    function handleTouchEnd(e) {
        this.classList.remove('dragging');
        document.querySelectorAll('.cell').forEach(c => c.classList.remove('over'));

        if (!isDraggingMode) {
            e.preventDefault();
            processInput(this);
        } else {
            const touch = e.changedTouches[0];
            const target = document.elementFromPoint(touch.clientX, touch.clientY);
            
            if (target && target.closest('.cell')) {
                const targetCell = target.closest('.cell');
                if (dragSrcEl !== targetCell && !targetCell.classList.contains('filler')) {
                    swapCells(dragSrcEl, targetCell);
                }
            }
        }
    }

    selectMode(1);
</script>

</body>
</html>
